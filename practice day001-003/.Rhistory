# 특수상수 is.na(), is.null()
is.na()
x <- ' '
is.na(x)
# 특수상수 is.na(), is.null()
x <- NA'
is.na(x)
# 난수 생성 함수
# 백터 생성 및 인덱스로 값 바꾸기
# 백터 비교
# 중복값 제거
# paste()
# substring()
# 논리 연산자
### 팬시인덱스: 조건에 의해 원하는 값을 추출ㅂ
# 특수상수 is.na(), is.null()
x <- NA
is.na(x)
x <- NA
is.na(x)
# 특수상수 is.na(), is.null()
x <- NA
is.na(x)
is.null(x)
# 난수 생성 함수
ranm()
# 난수 생성 함수
x <- rnorm(6, mean = 10) # 해당 수만큼 난수를 생성함
x
mean(x)
sum(x)
# 난수 생성 함수
x <- rnorm(5, mean = 10) # 해당 수만큼 난수를 생성함
x
sum(x)
# 백터 생성 및 인덱스로 값 바꾸기
v1 <- seq(1:5)
v2 <- seq(6:10)
v2 <- seq(6, 6:10)
v2 <- seq(6, 1:5)
v2 <- seq(6, 6:10, 1)
v2 <- seq(6, 10, 1)
v2 <- seq(from = 6, to = 10, by =1)
# 백터 비교
v1 == v2
# 중복값 제거
x <-rep(1, 5)
# 중복값 제거
x <-rep(1:2, 5, time = 2)
unique(x)
# substring()
substring('text blabla~ rstudio','r')
# substring()
substring('text blabla~ rstudio', 1, 4)
# paste()
paste('abc', 'def', 'ghi')
# paste()
paste('abc', 'def', 'ghi' sep = '*')
# paste()
paste('abc', 'def', 'ghi' sep = '*')
# paste()
paste('abc', 'def', 'ghi', sep = '*')
paste(v1[3], v2)
# 논리 연산자
T == F
T | F
T ! F
! T
# 팬시인덱스: 조건에 의해 원하는 값을 추출 # 셋다 [1] "logical"
x <- c(F, T, F, F, T)
y <- c(1:5)
y[x]
print(i)
for (i in sep(10)) {
print(i)
}
for (i in seq(10)) {
print(i)
}
print(total)
# 반복문
# 1 ~ 10의 수를 더한 결과를 추출
total <- 0 # 누적변수의 초기값
for (i in seq(10)) {
total <- print(i)
print(total)
}
# 반복문
# 1 ~ 10의 수를 더한 결과를 추출
total <- 0 # 누적변수의 초기값
for (i in seq(10)) {
total <- print(i)
total
}
# 반복문
# 1 ~ 10의 수를 더한 결과를 추출
total <- 0 # 누적변수의 초기값
for (i in seq(10)) {
total <- i
print(total)
}
# 반복문
# 1 ~ 10의 수를 더한 결과를 추출
total <- 0 # 누적변수의 초기값
for (i in seq(10)) {
total <- i
print(total+i)
}
# 반복문
# 1 ~ 10의 수를 더한 결과를 추출
total <- 0 # 누적변수의 초기값
for (i in seq(10)) {
total <- i +total
print(total)
}
paste(dan * i)
# 3단 만들기
dan <- 3
paste(dan * i)
paste(dan * i, ' = ', dan * i)
# 3단 만들기
dan <- 3
for(i in 1:9){
paste(dan * i, ' = ', dan * i)
}
cat(paste(dan, 'x', i, ' = ', dan * i)'/n')
cat(paste(dan, 'x', i, ' = ', dan * i)'\n')
# 3단 만들기
dan <- 3
for(i in 1:9){
cat(paste(dan, 'x', i, ' = ', dan * i)'\n')
# 3단 만들기
dan <- 3
for(i in 1:9){
cat(paste(dan, 'x', i, ' = ', dan * i,'\n'))
}
# 이용자가 입력하는 구구단 만들기
gugu <- function(){
dan <- readline("단을 입력해주세요: ")
dan <- as.integer(dan)
for(i in 1:9){
cat(paste(dan, 'x', i, ' = ', dan * i, '\n'))
}
}
gugu
gugu()
# 이용자가 입력하는 구구단 만들기
gu <- function(){
dan <- readline("단을 입력해주세요: ")
dan <- as.integer(dan)
for(i in 1:9){
cat(paste(dan, 'x', i, ' = ', dan * i, '\n'))
}
}
gu
gu()
# 구구단 전체 출력
for(dan in 2:9){
cat(paste(dan, '단 결과', \n))
# 구구단 전체 출력
for(dan in 2:9){
cat(paste(dan, '단 결과', '\n'))
}
# 구구단 전체 출력
for(dan in 2:9){
cat(paste(dan, '단 결과', '\n'))
for(i in 1:9){
cat(paste(dan, 'X', i, ' = ', dan * i, '\n'))
}
}
cat(paste('\n', dan, '단 결과', '\n'))
# 구구단 전체 출력
for(dan in 2:9){
cat(paste('\n', dan, '단 결과', '\n'))
for(i in 1:9){
cat(paste(dan, 'X', i, ' = ', dan * i, '\n'))
}
}
no <- c(1:4)
name <- c('apple', 'banana', 'peach', 'berry')
price <- c(500, 300, 800, 200)
qty <- c(5, 2, 7, 9)
fruit <- data.frame(No = no, Name = name, Price = price, Qty = qty)
## no, name, fruit를 test.dat 파일로 저장
save(fruit, file = 'C:/k_digital/r/source/test2.dat')
# 엑셀 파일을 읽어오는 방법
## 외부 패키지 불러오기 readxl
library(readxl)
rm(fruit)
# 저장된 데이터 불러오기
load('C:/k_digital/r/source/test2.dat')
# txt 파일 읽어오는 작업. 배열 형태로 읽어온다.
## 공백문자, 탭, 줄바꿈 등의 기준으로 단어 단위로 배열에 저장되서 처리된다.
## what = '자료형', 다양한 자료형이 섞여 있을 경우 what = ''
## UTF-8로 저장하면 한글이 깨질 수 있다. 메모장은 windows 한글지원(ms949)
a <- scan('C:/k_digital/data/sample.txt', what = '') # 배열이라 표가 아님
## 데이터 프레임 형태로 읽어오는 작업
## 이때 txt 파일의 커서는 데이터가 없는 마지막줄에 둬야 한다.
c <- read.table('C:/k_digital/data/sample.txt', header = T, sep = '\t')
### 주어진 행렬의 행들의 합을 계산
apply(d, 1, sum)
### apply(행렬, 방향, 함수): 행 or 열 방향으로 특정 함수를 적용할 때 사용
d <- matrix(1:9, ncol = 3)
### 주어진 행렬의 행들의 합을 계산
apply(d, 1, sum)
apply(d, 2, sum)
### iris 데이터의 각 컬럼(feature) 합을 계산
data(iris)
View(iris)
apply(iris, 2, sum)
apply(iris, 1, sum)
apply(iris[, -5], 2, sum)
colSums(iris)
colSums(iris[, -5])
## lapply(벡터 or 리스트, 함수) 결과가 리스트로 반환된다.
la <- lapply(2:4, function(x){x / 2})
la
# [[1]]
# [1] 1
#
# [[2]]
# [1] 1.5
#
# [[3]]
# [1] 2
## 리스트를 벡터로 변환하는 함수
unlist(la)
### 리스트를 데이터 프레임으로 변환할 때
### 1. unlist() 함수로 리스트를 벡터로 변환
unlist(iris[, -5])
### 리스트를 데이터 프레임으로 변환할 때
### 1. unlist() 함수로 리스트를 벡터로 변환
unlist(lapply(iris[, -5]))
### 리스트를 데이터 프레임으로 변환할 때
### 1. unlist() 함수로 리스트를 벡터로 변환
unlist(lapply(iris[, -5]), mean)
### 리스트를 데이터 프레임으로 변환할 때
### 1. unlist() 함수로 리스트를 벡터로 변환
unlist(lapply(iris[, -5]), mean))
### 리스트를 데이터 프레임으로 변환할 때
### 1. unlist() 함수로 리스트를 벡터로 변환
unlist(lapply(iris[, -5], mean))
### 2. matrix() 함수로 벡터를 행렬로 변환
matrix(lapply(iris[, -5], mean))
### 2. matrix() 함수로 벡터를 행렬로 변환
matrix(unlist(lapply(iris[, -5], mean)))
matrix(unlist(lapply(iris[, -5], mean)), ncol = 4, byrow = T)
### 2. matrix() 함수로 벡터를 행렬로 변환
matrix(unlist(lapply(iris[, -5], mean)), byrow = T)
### 3. as.data.frame() 함수로 행렬을 데이터 프레임으로 변환
as.data.frame(matrix(unlist(lapply(iris[, -5], mean)), ncol = 4, byrow = T))
#         V1       V2    V3       V4
# 1 5.843333 3.057333 3.758 1.199333
### 4. names() 함수로 리스트로부터 컬럼명을 얻어와 데이터 프레임에 부여
na <- names(iris[, -5])
df <- as.data.frame(matrix(unlist(lapply(iris[, -5], mean)), ncol = 4, byrow = T))
names(df) <- na
df
# sapply: lapply와 유사하지만 리스트 대신 행렬, 벡터 등으로 결과가 반환된다.
## iris 컬럼별 평균 계산
sapply(iris[, -5], mean)
# Sepal.Length  Sepal.Width Petal.Length  Petal.Width
# 5.843333     3.057333     3.758000     1.199333
class(sapply(iris[, -5], mean)) # [1] "numeric"
as.data.frame(sapply(iris[, -5], mean))
as.data.frame(t(sapply(iris[, -5], mean)))
#   Sepal.Length Sepal.Width Petal.Length Petal.Width
#      5.843333    3.057333        3.758    1.199333
# tapply(데이터, 색인_어떤 그룹에 속하는 지 표현하는 것, 함수): 그룹별 처리를 위한 apply 함수
tapply(1:10, rep(1, 10), sum)
#   Sepal.Length Sepal.Width Petal.Length Petal.Width
#      5.843333    3.057333        3.758    1.199333
# tapply(데이터, 색인_어떤 그룹에 속하는 지 표현하는 것, 함수): 그룹별 처리를 위한 apply 함수
tapply(1:10, rep(1, 5), sum)
#   Sepal.Length Sepal.Width Petal.Length Petal.Width
#      5.843333    3.057333        3.758    1.199333
# tapply(데이터, 색인_어떤 그룹에 속하는 지 표현하는 것, 함수): 그룹별 처리를 위한 apply 함수
tapply(1:5, rep(1, 5), sum)
1+2+3+4+5
#   Sepal.Length Sepal.Width Petal.Length Petal.Width
#      5.843333    3.057333        3.758    1.199333
# tapply(데이터, 색인_어떤 그룹에 속하는 지 표현하는 것, 함수): 그룹별 처리를 위한 apply 함수
tapply(1:5, rep(1, 10), sum)
#   Sepal.Length Sepal.Width Petal.Length Petal.Width
#      5.843333    3.057333        3.758    1.199333
# tapply(데이터, 색인_어떤 그룹에 속하는 지 표현하는 것, 함수): 그룹별 처리를 위한 apply 함수
tapply(1:5, rep(2, 5), sum)
#   Sepal.Length Sepal.Width Petal.Length Petal.Width
#      5.843333    3.057333        3.758    1.199333
# tapply(데이터, 색인_어떤 그룹에 속하는 지 표현하는 것, 함수): 그룹별 처리를 위한 apply 함수
tapply(1:5, rep(6, 5), sum)
#   Sepal.Length Sepal.Width Petal.Length Petal.Width
#      5.843333    3.057333        3.758    1.199333
# tapply(데이터, 색인_어떤 그룹에 속하는 지 표현하는 것, 함수): 그룹별 처리를 위한 apply 함수
tapply(1:5, rep(2, 5), sum)
# 2
# 15
## 홀,짝별로 묶어서 합계를 구하시오.
tapply(1:10, 2 %% 1 = 0, sum)
# 2
# 15
## 홀,짝별로 묶어서 합계를 구하시오.
tapply(1:10, 1:10 %% 2 = 0, sum)
# 2
# 15
## 홀,짝별로 묶어서 합계를 구하시오.
tapply(1:10, 1:10 %% 2 = 0, sum)
# 2
# 15
## 홀,짝별로 묶어서 합계를 구하시오.
tapply(1:10, 1:10 %% 2 == 0, sum)
m <- matrix(1:8, ncol = 2, dimnames = list(c('spring', 'summer', 'fall', 'winter'),c('male', 'female')))
#         male female
# spring    1      5
# summer    2      6
# fall      3      7
# winter    4      8
### 분기별 남성과 여성 합계를 구하시오.
### 상반기(봄, 여름), 하반기(가을, 겨울)
tapply(c(m[1:2, 1]), c(m[1:2, 2]), sum)
tapply(m, list(c(1, 1, 2, 2, 1, 1, 2, 2), c(1, 1, 1, 1, 2, 2, 2, 2)), sum)
